#!/usr/bin/env python
#
# A simple urlview replacement that handles things like quoted-printable
# properly.  aka "urlview minus teh suck"
#
#   Copyright (C) 2006-2007 Daniel Burrows
#   Copyright (C) 2014 Scott Hansen
#
#   This program is free software; you can redistribute it and/or
#   modify it under the terms of the GNU General Public License as
#   published by the Free Software Foundation; either version 2 of the
#   License, or (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#   General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; see the file COPYING.  If not, write to
#   the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
#   Boston, MA 02111-1307, USA.

from __future__ import unicode_literals
import argparse
import os
import sys
from urlscan import urlchoose, urlscan
try:
    from email.Parser import Parser as parser
except ImportError:
    from email.parser import Parser as parser


def msgurls(msg, urlidx=1):
    # Written as a generator so I can easily choose only
    # one subpart in the future (e.g., for
    # multipart/alternative).  Actually, I might even add
    # a browser for the message structure?
    enc = urlscan.get_charset(msg)
    if msg.is_multipart():
        for part in msg.get_payload():
            for chunk in msgurls(part, urlidx):
                urlidx += 1
                yield chunk
    elif msg.get_content_type() == 'text/plain':
        msg = decode_bytes(msg.get_payload(decode=True), enc)
        for chunk in urlscan.extracturls(msg):
            urlidx += 1
            yield chunk
    elif msg.get_content_type() == 'text/html':
        msg = decode_bytes(msg.get_payload(decode=True), enc)
        for chunk in urlscan.extracthtmlurls(msg):
            urlidx += 1
            yield chunk


def decode_bytes(b, enc='utf-8'):
    """Given a string or bytes input, return a string.

    If the default encoding or detected encoding don't work, try 'latin-1'

        Args: b - bytes or string
              enc - encoding to use for decoding the byte string.

    """
    try:
        s = b.decode(enc)
    except UnicodeDecodeError:
        try:
            s = b.decode('latin-1')
        except UnicodeDecodeError as e:
            s = "Unable to decode message:\n{}\n{}".format(str(b), e)
    except AttributeError:
        # If b is already a string, just return it
        return b
    return s


def parse_arguments():
    """Parse command line options.

    Returns: args

    """
    arg_parse = argparse.ArgumentParser(description="Parse and display URLs")
    arg_parse.add_argument('--compact', '-c',
                           action='store_true', default=False,
                           help="Don't display the context of each URL.")
    arg_parse.add_argument('message', type=argparse.FileType('r'),
                           help="Filename or pipe content using '-' for stdin")
    args = arg_parse.parse_args(sys.argv[1:])
    return args


if __name__ == "__main__":
    args = parse_arguments()
    msg = parser().parse(args.message)
    # This section closes out sys.stdin if necessary so as not to block curses
    # keyboard inputs
    if not os.isatty(0):
        fd = os.open('/dev/tty', os.O_RDONLY)
        if fd < 0:
            sys.stderr.write('Unable to open an input tty.\n')
            sys.exit(-1)
        else:
            os.dup2(fd, 0)
            os.close(fd)
    ui = urlchoose.URLChooser(msgurls(msg),
                              compact_mode=args.compact)
    ui.main()
